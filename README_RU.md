# Привет!
&nbsp;

---
## Это приложение написано на "JavaScript ES6" и "Php" с использованием баз данных "SQL" через серверную платформу "OpenServer" и стилизуется с помощью фреймворка "Materialize".
&nbsp; 
# **Внимание!**
## **Приложение тестировалось и корректно работало на серверной платформе "OpenServer", я не гарантирую работу приложения на других серверных платформах. Для максимально корректной работы приложения - рекомендуется придерживаться шагов по тестированию приложения приведенных ниже!** 
&nbsp;
## Если вы хотите протестировать работу приложения, то вам потребуется:
&nbsp; 
### **1. `Скачать и установить "basic" версию "`[OpenServer](https://ospanel.io)`" с официального сайта`;**
### **2. `Создать папку "www" и перетащить в неё все файлы из папки "Cabinet_on_JavaScript"`;**
### **3. `Далее, нужно положить папку "www" в папку "domains" приложения "OpenServer" (клик мышкой по значку в трее, и выбираем "Папка с проектами")`;**
### **4. `После выполнения всех предыдущих шагов, открываем "OpenServer". Далее перейдите в "Настройки", выберите вкладку "Модули". В выпадающем списке "MySQL / MariaDB" выберите последнюю версию "MySQL" (на данный момент "MySQL-8.0-Win10") и сохраните изменения`;**
### **5. `Закрываем настройки и нажимаем "Запустить", затем переходим во вкладку "Дополнительно" и выбираем приложение "PhpMyAdmin" - для работы с базами данных`;**
### **6. `Вводим логин и пароль, по умолчанию: "root", "" (поле для пароля оставьте пустым)`**;
### **7. `Теперь нужно создать базу данных, в левой части нажимаем на "Создать БД", вводим название "cabinet_on_javascript" и оставляем кодировку по умолчанию, нажимаем "Создать"`;**
### **8. `Выбираем "созданную" БД и справа на верхней панели инструментов выбираем "Импорт", теперь нужно указать файл "SQL" из папки "www", после выбора прокручиваем до низу и нажимаем "Вперёд". Теперь вы можете прослеживать зарегестрированных пользователей и их личные данные в "cabinet_on_javascript"`.**
### **9. `Теперь вернемся в приложение "OpenServer" и выберем вкладку "Мои проекты", из списка выбираем проект "www". Запустится приложение "Сabinet on JavaScript"`.**
&nbsp;

## **Наконец вы можете начинать тестировать приложение!**

---
&nbsp;

# 1. Введение
&nbsp;

---
### "Cabinet on JavaScript" - это приложение написанное на "JavaScript ES6" и "Php", использующее серверную среду разработки "OpenServer" и фреймворк "Materialize" - для стилизации приложения. Оно представляет из себя возможность для пользователя зарегистрироваться в системе или авторизоваться и зайти в свой личный кабинет. В личном кабинете он всегда может поменять свои личные данные или разлогиниться из него.
### Данное приложение имеет "фронтенд" и "бэкенд" часть и работает через "ajax-запросы". Работа приложения выглядит так: пользователь вводит свои данные в форму, подтверждает введенные данные, данные отправляются на сервер в базу данных, и при дальнейшей авторизации, пользователь входит в свой личный кабинет.
### В личном кабинете для авторизованного пользователя из базы данных загружаются его личные данные и выводятся в соответствующие поля. При изменении личных данных пользователем, обновленные данные также отправляются на сервер в базу данных, и при повторном входе в личный кабинет, подзагружаются новые личные данные пользователя которые он изменил.
### Также пользователь может разлогиниться из личного кабинета и тогда логин и пароль придеться вводить снова. В этом приложении активно использовались "cookie" файлы для взаимодействия с личным кабинетом, а также для обновления его данных.
---
&nbsp;

# 2. Ознакомление
&nbsp;

---
### Давайте познакомимся с архитектурой проекта.
### В основной папке проекта находятся файлы: "cabinet.php" - основной файл содержащий верстку личного кабинета пользователя; "favicon.png" - иконка для приложения; "index.html" - основной файл содержащий верстку приложения; файл "user_cabinet.sql" - содержит шаблон таблицы для базы данных зарегистрированных пользователей.
### В папке "core" находятся файлы для работы с базой данных: "config.php" - содержит данные для доступа к базе данных; "get_user_data.php" - нужен для получения из базы данных личных данных пользователя; "login.php" - нужен для авторизации пользователя при логировании; "signup" - нужен для авторизации пользователя при регистрации; "update_user_data.php" - нужен для обновления данных пользователя в базе данных.
### В папке "css" находятся все стили приложения: "materialize.css" - стили от фрэймворка "Materialize"; "materialize.min.css" - стили от фрэймворка "Materialize" в минификации; "style.css" - общие стили приложения.
### В папке "js" расположены файлы для работы фрэймворка "Materialize": "materialize.js" - основной скрипт файл для работы "Materialize"; "materialize.min.js" - тот же файл в минификации.
### В папке "script" расположены основные файлы для работы приложения: "ajax.js" - файл содержащий общий для всех ajax-запрос; "get_user_data.js" - файл содержащий работу личного кабинета пользователя; "logout.js" - файл содержащий работу выхода из личного кабинета; "main.js" - файл содержащий работу модальных окон при авторизации; "script.js" - файл содержащий работу для логирования и регистрации пользователя. 
---
&nbsp;

# 3. Обзор
&nbsp;

---
### Время для подробного описания кода приложения.
### Так как работа с авторизацией пользователя напрямую связана с серверной частью, то было необходимо отдельно создать бэкенд-часть на языке "Php". Она находится в папке "core" и содержит несколько необходимых файлов для работы с базой данных. Разберем вкратце эти файлы.
---
&nbsp;

---
### Файл "config.php" - содержит данные для доступа к базе данных: "сервер", "логин", "пароль", "название базы данных".

```

<?php

$servername = "localhost";
$username = "root";
$password = "root";
$dbname = "cabinet_on_javascript";

```
---
&nbsp;

---
### Файл "signup.php" - содержит обработку формы, отправленную пользователем при регистрации.

```

<?php
require_once 'config.php';

$name = trim($_POST['name']);
$pass = trim($_POST['pass']);
$email = trim($_POST['email']);
$birthday = trim($_POST['birthday']);
$sex = trim($_POST['sex']);

if ($name =='' OR $pass=='' OR $email=='' OR $birthday=='' OR $sex ==''){
    echo 2;
    die;
}

// Create connection
$conn = new mysqli($servername, $username, $password, $dbname);
// Check connection
if ($conn->connect_error) {
    die("Connection failed: " . $conn->connect_error);
} 

$sql = "INSERT INTO users (name, email, password, birthday, sex) VALUES ('".$name."', '".$email."', '".$pass."', '".$birthday."', '".$sex."')";

if ($conn->query($sql) === TRUE) {
    echo 1;
} else {
    echo "Error: " . $sql . "<br>" . $conn->error;
}

$conn->close();
?>

```

### Он записывает в базу данных "sql" данные нового пользователя и хранит их.
---
&nbsp;

---
### Файл "login.php" - содержит обработку формы, отправленную пользователем при логировании.

```

<?php
require_once 'config.php';

$email= trim($_POST['email']);
$pass = trim($_POST['pass']);

if ($email =='' OR $pass==''){
    echo 2;
    die;
}

// Create connection
$conn = new mysqli($servername, $username, $password, $dbname);
// Check connection
if ($conn->connect_error) {
    die("Connection failed: " . $conn->connect_error);
} 

$sql = "SELECT name, email FROM users WHERE email='".$email."' and password='".$pass."'";
$result = $conn->query($sql);

if ($result->num_rows > 0) {
    // output data of each row
    $row = $result->fetch_assoc();
    echo json_encode($row);
} else {
    echo "0";
}
$conn->close();
?>

```

### Он проверяет в базе данных "sql" данные зарегистрированного пользователя и возвращает его данные.
---
&nbsp;

---
### Файл "get_user_data.php" - получает из базы данных сервера личные данные конкретного пользователя, отправляя их в личный кабинет.

```

<?php
require_once 'config.php';

$email= trim($_POST['email']);

if ($email ==''){
    echo 2;
    die;
}

// Create connection
$conn = new mysqli($servername, $username, $password, $dbname);
// Check connection
if ($conn->connect_error) {
    die("Connection failed: " . $conn->connect_error);
} 

$sql = "SELECT * FROM users WHERE email='".$email."'";
$result = $conn->query($sql);

if ($result->num_rows > 0) {
    // output data of each row
    $row = $result->fetch_assoc();
    echo json_encode($row);
} else {
    echo "0";
}
$conn->close();
?>

```

### Для этого ему посылается "email" пользователя.
---
&nbsp;

---
### Файл "update_user_data.php" - получает обновленные данные пользователя из личного кабинета, и обновляет базу данных.

```

<?php
require_once 'config.php';

$email= trim($_POST['email']);
$name= trim($_POST['name']);
$pass= trim($_POST['pass']);
$birthday= trim($_POST['birthday']);
$sex= trim($_POST['sex']);

if ($email ==''){
    echo 2;
    die;
}

// Create connection
$conn = new mysqli($servername, $username, $password, $dbname);
// Check connection
if ($conn->connect_error) {
    die("Connection failed: " . $conn->connect_error);
} 

$sql = "UPDATE users SET name='".$name."', password='".$pass."', birthday='".$birthday."', sex='".$sex."' WHERE email='".$email."'";

if ($conn->query($sql) === TRUE) {
    echo 1;
} else {
    echo "Error updating record: " . $conn->error;
}

$conn->close();
?>

```
---
&nbsp;

---
### Разберем файлы из папки "script".
### В файле "ajax.js" создается ajax-запрос на бэкенд-сервер. Функция ajax  принимает несколько параметров: "url" - содержит путь к "php" - файлам для обработки запроса; "method" - содержит вариант метода запроса; "functionName" - содержит функцию, которая получает ответ с сервера; "dataArray" - содержит объект с данными пользователя.

```

function ajax(url, method, functionName, dataArray) {
    let xhttp = new XMLHttpRequest();
    xhttp.open(method, url, true);
    xhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    xhttp.send(requestData(dataArray));
    xhttp.onreadystatechange = function () {
        if (this.readyState == 4 && this.status == 200) {
            functionName(this.response);
        }
    }
}

function requestData(dataArr) {
    let out = "";
    for (let key in dataArr) {
        out += `${key}=${dataArr[key]}&`;
    }
    return out;
}

```

### Создаем новый "XMLHttp-запрос". Указываем метод запроса, адрес запроса и ассинхронность. Прописываем заголовки запроса. Отправляем функцию "requestData(dataArray)" в параметре передаем объект с данными пользователя. 
### Функция "requestData(dataArr)" - нужна для создания query-строки с данными пользователя и дальнейшей отправки ее на сервер. В самой функции происходит обычный перебор объекта по ключам, и дописованием его содержимого через амперсанд("&") в переменную "out". При отправки функции на сервер, она возвращает созданную query-строку.
### Далее после отправки данных пользователя на сервер, мы прописываем получаемый ответ через анонимную функцию и если запрос был успешен, то в функцию для получения ответа записываем результат ("functionName").
---
&nbsp;

---
### В файле "script.js" - находится код для отправки данных с формы регистрации и логирования на сервер. Для удобства разделим код на две части: "регистрация" и "логирование".
### Для блока регистрации мы получаем по "id" кнопку для отправки формы со страницы и вешаем собитие-click с анонимной функцией.

```

document.querySelector('#signup-submit').onclick = function (event) {
    event.preventDefault();
    let name = document.querySelector('#signup-name').value;
    let pass = document.querySelector('#signup-pass').value;
    let email = document.querySelector('#signup-email').value;
    let birthday = document.querySelector('#signup-birthday').value;
    let sex = document.querySelectorAll('.sex');
    for (let i = 0; i < sex.length; i++) {
        if (sex[i].checked) {
            sex = sex[i].value;
            break;
        }
    }
    let data = {
        'name': name,
        'pass': pass,
        'email': email,
        'birthday': birthday,
        'sex': sex,
    }
    ajax('core/signup.php', 'POST', signup, data);

    function signup(result) {
        if (result == 2) {
            M.toast({ html: 'Fill in the fields!', classes: 'toast' });
        }
        else if (result == 1) {
            M.toast({ html: 'You have successfully registered!', classes: 'toast' });
            closeModal();
        }
        else {
            M.toast({ html: 'Error! Try to register again!', classes: 'toast' });
        }
    }
}

```

### В функции сначала отменяем событие по умолчанию, а затем по "id" получаем в переменные значения из полей формы. Так как "sex" имеет три варианта выбора, мы через цикл "for" находим и записываем в переменную "sex" выбранное пользователем значение.
### Далее для отправки данных с формы на сервер, нам понадобится создать объект, содержащий в себе все раннее созданные переменные с данными пользователя. Этот объект "data" мы будем отправлять в качестве параметра в ajax-функцию в файле "ajax.js". Итак ниже после создания объекта "data", в ajax-запрос передаем параметры: url-путь к файлу регистрации "signup.php"; метод запроса; функцию "signup" - которая будет получать ответ; объект "data" с данными пользователя.
### Функция "signup" в качестве параметра принимает ответ с сервера и в зависимости от полученного ответа, отображает всплывающее сообщение: 2 - заполните поля; 1 - успех; 0 - ошибка регистрации.
---
&nbsp;

---
### Для блока логирование мы сделаем похожие вещи.
### Получаем кнопку формы по 'ID", вышаем на нее событие клик с анонимной функцией. В функции отменяем дефолтное событие, и в переменные получаем значения из полей логирования.

```

document.querySelector('#login-submit').onclick = function (event) {
    event.preventDefault();
    let pass = document.querySelector('#login-pass').value;
    let email = document.querySelector('#login-email').value;

    let data = {
        'pass': pass,
        'email': email,
    }
    ajax('core/login.php', 'POST', login, data);

    function login(result) {
        console.log(result)
        if (result == 2) {
            M.toast({ html: 'Fill in the fields!', classes: 'toast' });
        }
        else if (result == 0) {
            M.toast({ html: 'No such user found!', classes: 'toast' });
        }
        else {
            result = JSON.parse(result);
            let d = new Date();
            d.setTime(d.getTime() + (10 * 60 * 1000));
            let expires = d.toUTCString();
            document.cookie = `email=${result.email}; expires=${expires}; path=/`;
            location.href = "cabinet.php";
        }
    }
}

```

### Создаем объект "data" с данными пользователя. Затем передаем в ajax-функцию параметры: путь к файлу "login.php"; метод запроса ("POST"); функцию "login" - для обработки ответа с сервера; объект "data" с данными пользователя. Функция "login" претерпела некоторые изменения в сравнении с "signup функцией".
### Логирование мы будем делать через cookie, а именно создавать и сохранять параметры авторизованного пользователя в браузере. Чтобы создать cookie, нам необходимо преобразовать наш результат , полученный с сервера, в объект с помощью "JSON.parse()". Затем создаем новый объект "Date" и присваиваем в переменную "d". Созданному объекту задается время через метод "setTime()". Внутри "setTime()" время вычисляется по формуле: текущее время ("d.getTime()") плюс время жизни в милисекундах (10 * 60 * 1000). Далее создаем новую переменную "expires" , и в нее записываем объект с датой преобразованный в формат UTC методом "toUTCString()". Теперь мы можем создать cookie использовав "document.cookie" и записав в него: ключ "email" со значением из объекта "result"; ключ "expires" со значением раннее созданного объекта "expires"; ключ "path" со значением "/".
### Также после создания cookie с данными пользователя, нам необходимо перейти в личный кабинет. Для этого в "location.href" прописываем путь к файлу "cabinet.php".
---
&nbsp;

---
### Для ясности процесса работы приложения, нужно кратко объяснить работу cookie файлов.
### Cookie файлы - это файлы хранящиеся в браузере пользователя. Они необходимы для хранения данных пользователя, например данных для входа в личный кабинет. Благодаря им пользователь может повторно зайти в личный кабинет, не вводя постоянно свои данные.
### Cookie файлы удаляются автоматически при прохождении определенного количества времени, это нужно в целях безопасности и конфиденциальности пользователя. Обычно к cookie применяется шифрование, превращая ее в случайных набор символов в целях безопасности, но в данном приложении для понимания его работы и наглядной демонстрации, шифрование cookie не применялось.
### А теперь разберем работу логирования с помощью cookie файлов.
---
&nbsp;

---
### Файл "cabinet.php" находится в основной папке проекта. Он содержит верстку личного кабинета пользователя. Но перед рендерингом страницы с личным кабинетом пользователя, проводится проверка в cookie на наличие: email пользователя; проверка email пользователя на пустую строку.

```

<?php
    //var_dump($_COOKIE);
    if ( !isset($_COOKIE['email']) OR trim($_COOKIE['email']) ==''){
        header("Location: index.html");
        exit; 
    }
?>

```

### Если проверка не проходит, иными словами, cookie с данными пользователя нет, то пользователя, при попытке перейти в личный кабинет, будет перенаправлять на страницу авторизации. В случае наличия cookie пользователя, будет рендериться страница с личным кабинетом пользователя.
---
&nbsp;

---
### Теперь перейдем к работе личного кабинета пользователя.
### Первое что нужно сделать, это конечно выход из личного кабинета. Выход из личного кабинета подразумевает, что пользователь не сможет зайти в кабинет снова, не пройдя повторную авторизацию, а значит нам понадобится получить необходимую cookie с данными пользователя и удалить её. Эту функцию выполняет файл "logout.js" находящийся в папке "script".
### Внутри файла мы вешаем на кнопку "logout" событие клик с анонимной функцией. Внутри функции мы получаем cookie в переменную "c".

```

document.querySelector('#logout').onclick = function () {
    let c = document.cookie;
    console.log(c);
    let d = new Date();
    d.setTime(d.getTime() - (10 * 60 * 1000));
    let expires = d.toUTCString();
    document.cookie = `${c}; expires=${expires}; path=/`;
    location.reload();
}

```

### Затем проделываем те же операции по созданию cookie что и в первый раз, за исключением небольшой детали. Удалять cookie мы будем следующим образом: уменьшая ее время жизни до минус одной минуты(d.getTime() - (10 * 60 * 1000), что в свою очередь удалит ее автоматически при нажатии на кнопку "logout".
### В конце всех операций по удалению cookie, проводим перезагрузку страницы ("location.reload()"), а так как cookie хранящая данные авторизации пользователя была удалена, пользователь был отправлен на страницу повторной авторизации.
---
&nbsp;

---
### В личном кабинете также должна быть возможность изменить и обновить данные пользователя. Чтобы это реализовать, нам нужно получать данные авторизованного пользователя. Разделим работу личного кабинета на две части: "получение данных пользователя через cookie браузера"; "отправление изменненых данных пользователя на сервер".
---
&nbsp;

---
### Файл "get_user_data.js" из папки "script", будет получать данные пользователя через cookie браузера, отправлять уникальный email пользователя по ajax-запросу на файл "get_user_data.php" и получать ответ содержащий данные конкретного пользователя и выводить на страницу личного кабинета.
### Также в "get_user_data.js" прописаны функции по отправке обновленных данных пользователя на файл "update_user_data.js", который в свою очередь обновляет базу данных пользователей и вносит поправки в данные пользователя при изменении личного кабинета.
### Работа файла "get_user_data.js" начинается со специальной функции фреймворка "Materialize" с официального сайта документации. Эта функция нужна для корректного вызова календаря при нажатии на поле с датой рождения пользователя в личном кабинете. Она срабатывает при загрузке "DOM" документа через слушатель событий.

```

document.addEventListener('DOMContentLoaded', function () {
    let elems = document.querySelectorAll('.datepicker');
    let instances = M.Datepicker.init(elems, {
        "format": "yyyy-mm-dd"
    });
});

```

### Внутри функции осуществляется получение со страницы элемента с полем для даты. Затем через специальный метод "Materialize" передается объект с нужным форматом вывода даты.
---
&nbsp;

---
### Теперь разберем работу по получению cookie пользователя.
### Функция "getCookie" при вызове получает параметр "email" из переменной "userEmail". Внутри функции в переменную "name" ложится наш параметр со значением "email" и к нему дописывается знак "=". Далее получаем cookie из браузера, но сначала нужно их декодировать через метод "decodeURIComponent(document.cookie)".

```

function getCookie(cname) {
    let name = cname + '=';
    let decodedCookie = decodeURIComponent(document.cookie);
    let ca = decodedCookie.split(';');
    for (let i = 0; i < ca.length; i++) {
        let c = ca[i];
        while (c.charAt(0) == ' ') {
            c = c.substring(1);
        }
        if (c.indexOf(name) == 0) {
            return c.substring(name.length, c.length);
        }
    }
    return "";
}

```

### Теперь нужно разбить полученные cookie на массив строк методом "split(';')" указав разделитель ";", получаем массив "co". Затем перебираем массив через цикл "for". В переменную "c" записываем каждый элемент массива.
### Ниже проводим проверку циклом "while" методом "с.charAt(0)" - пока первый символ элемента массива равен "пробелу", то в "c" записываем все символы что идут после первого методом "c.substring(1)".
### И последняя проверка проверяет через метод "indexOf(name)" наличие на нулевом индексе строку "email=", в случае успеха, к "c" применяется метод "substring" в котором указывается начало от длины переменной "name",в которой лежит наш "email=",  и до длины самого "c", что в итоге нам дает строку содержащую только адрес электроной почты пользователя без приставки "email=", например:

```
"example@gmail.соm"
```
### , а не как было изначально при получении cookie:

```
"email=example@gmail.com"
```

---
&nbsp;

---
### Саму функцию "getCookie(cname)" мы ложим в переменную userEmail, передавая в качестве параметра строку "email".

```

let userEmail = getCookie('email');

```
---
&nbsp;

---
### Итак, с получением электронной почты пользователя через cookie мы разобрались, теперь же пора взяться за функцию, которая у нас будет получать данные пользователя по "email" с сервера и подставлять в нужные нам поля ввода.
---
&nbsp;

---
### Функция "getUserData()" принимает параметр "result", в котором содержится ответ сервера с данными пользователя. Данный ответ нужно преобразовать в объект методом "JSON.parse(result)".

```

function getUserData(result) {
    result = JSON.parse(result);
    console.log(result);
    document.querySelector('#signup-name').value = result.name;
    document.querySelector('#signup-pass').value = result.password;
    document.querySelector('#signup-birthday').value = result.birthday;
    let sex = document.querySelectorAll('.sex');
    for (let i = 0; i < sex.length; i++) {
        if (result.sex == sex[i].value) {
            sex[i].setAttribute('checked', 'checked');
        }
    }
    M.updateTextFields();

}

```

### Из полученного объекта "result", берем и вставляем нужные нам значения в соответствующие поля полученные по ID со страницы.
### Для поля с radio-кнопками делаем несколько действий: получаем со страницы все radio-кнопки; перебираем их циклом "for"; делаем проверку на совпадение пола из "result"; если совпадение найдено, то задаем аттрибут "checked" для radio-кнопки.
### В конце функции прописываем специальный метод от "Materialize" из документации официального сайта, необходимый для корректного отображения label для полей ввода.
---
&nbsp;

---
### Наконец можно отправлять запрос на сервер для получения личных данных пользователя.

```

ajax('core/get_user_data.php', 'POST', getUserData, { "email": userEmail });

```

### Для этого прописываем ajax-запрос и указываем параметры: путь к файлу "get_user_data.php"; метод запроса "POST"; функцию "getUserData" - для обработки ответа от сервера; объект содержащий "email" пользователя по которому нам нужно получить личные даные.
---
&nbsp;

---
### На этом работа по получению данных пользователя окончена, теперь разберем работу по отправке обновленных данных пользователя в базу данных сервера.
---
&nbsp;

---
### На кнопку "UPDATE" в личном кабинете, вешается событие "click" с анонимной функцией. Внутри функции останавливается дефолтное событие формы.

```

document.querySelector('#signup-submit').onclick = function (event) {
    event.preventDefault();
    let sex = document.querySelectorAll('.sex');
    for (let i = 0; i < sex.length; i++) {
        if (sex[i].checked) {
            sex = sex[i].value;
            break;
        }
    }
    let updateData = {
        "email": userEmail,
        "name": document.querySelector('#signup-name').value,
        "pass": document.querySelector('#signup-pass').value,
        "birthday": document.querySelector('#signup-birthday').value,
        "sex": sex
    }
    ajax('core/update_user_data.php', 'POST', updateUserData, updateData);
}

```

### Далее получаем все radio-кнопки для выбора пола, перебираем их циклом "for" и проверяем каждую кнопку на аттрибут "checked", если условие прошло, то в переменную "sex" ложим выбранное значение и останавливаем цикл.
### Затем создаем объект в который ложим: ключ "email" и значение переменной "userEmail"; ключ "name" и значение из поля "name"; ключ "pass" и значение из поля "pass"; ключ "birthday" и значение из поля "birthday"; ключ "sex" и значение выбранное radio-кнопкой.
### После проведенных операций, отправляем ajax-запрос со следующими параметрами: путь к файлу "update_user_data.php"; метод запроса "POST"; функция "updateUserData" - для получения ответа с сервера; объект "updateData" - с обновленными данными пользователя.
### Функция "updateUserData" получает в качестве параметра ответ с сервера, который проверяется условием на равенство с "1"("успех"), если условие верно, то через специальный метод "toast" от "Materialize", во всплывающем уведомлении выводится сообщение об успешном изменении данных, если условие неверно, то выводится сообщение об ошибке.
---
&nbsp;

---
### Теперь разберем работу файла "main.js".
### В файле "main.js" - происходит работа модальных окон авторизации. В начале идет уже знакомый нам код "Materialize", необходимый для работы календаря в пункте "дата рождения" при регистрации пользователя.

```

document.addEventListener('DOMContentLoaded', function () {
    let elems = document.querySelectorAll('.datepicker');
    let instances = M.Datepicker.init(elems, {
        "format": "yyyy-mm-dd"
    });
});

```

### Ниже идет работа модальных окон. На кнопки "login" и "sign up" назначается событие клик с функцией "showModal".

```

document.querySelectorAll('.modal-show').forEach(function (element) {
    element.onclick = showModal;
});

```

### По умолчанию всем модальным окнам присвоен класс "hide" - скрывающий их со страницы, именно функция "showModal" показывает конкретное модальное окно, в зависимости от нажатой кнопки, удаляя этот класс.
---
&nbsp;

---
### Функция "showModal" получает в переменную "modalId" data-аттрибут нажатой кнопки: "#login-in" или "#sign-up".

```

function showModal() {
    let modalId = this.dataset.modal;
    document.querySelector(modalId).classList.remove('hide');
    document.onkeydown = function (event) {
        if (event.keyCode == 27) closeModal();
    }
}

```

### Теперь мы имеем фактически ID нужной нам кнопки, и чтобы для конкретного модального окна выполнить его показ на странице, надо просто его получить по его ID равному переменной "modalID" и удалить его класс "hide".
### Также повесим событие для закрытия модального окна при нажатии на клавишу "Esc". На документ вешаем событие "onkeydown()" с анонимной функцией. Внутри функции делаем проверку на условие: если нажатая клавиша равна "Esc", то выполняем функцию "closeModal" закрывающую модальное окно.
---
&nbsp;

---
### Помимо основной работы на открытие и закрытие модального окна, в функции showModal() прописаны действия по изменению фоновой картинки при нажатии на кнопки "login" или "sign up". Делается это следующим образом.
### Сначала получаем всех наследников блока "authorization-block" в переменную "mainImg". Затем следует два условия: для кнопки "login"; для кнопки "sign up".

```

let mainImg = document.querySelector('.authorization-block').children;
    if (modalId == "#sign-up") {
        for (let i = 0; i < mainImg.length; i++) {
            if (mainImg[i].classList.contains('authorization-block__registration')) {
                mainImg[i].classList.remove('_hide');
            }
            else {
                mainImg[i].classList.add('_hide');
            }
        }
    }
    else if (modalId == "#login-in") {
        for (let i = 0; i < mainImg.length; i++) {
            if (mainImg[i].classList.contains('authorization-block__login')) {
                mainImg[i].classList.remove('_hide');
            }
            else {
                mainImg[i].classList.add('_hide');
            }
        }
    }

```

### В обоих условиях элементы блока "authorization-block" перебираются циклом "for". Всего блоков три: "reception" , "registration" и "login". В цикле прописаны дополнительные условия: если блок содержит класс с "registration" или "login" - то данный блок показывается на странице путем удаления специального класса "_hide", а остальные скрываются благодаря добавлению к ним класса "_hide".
---
&nbsp;

---
### Функция "closeModal" получает все модальные окна и каждому присваевает класс "hide" - скрывая их со страницы.

```

function closeModal() {
    document.querySelectorAll('.modal-wrap').forEach(function (element) {
        element.classList.add('hide');

    });
    document.onkeydown = null;
}

```

### Также она обнуляет событие на клавишу "Esc" после закрытия модального окна.
---
&nbsp;

---
### Как и в функции "showModal()", в функции "closeModal()" имеется работа с фоновым изображением.

```

let mainImg = document.querySelector('.authorization-block').children;
    for (let i = 0; i < mainImg.length; i++) {
        if (mainImg[i].classList.contains('authorization-block__reception')) {
            mainImg[i].classList.remove('_hide');
        }
        else {
            mainImg[i].classList.add('_hide');
        }
    }

```

### При закрытии модального окна, все блоки "authorization-block" будут скрываться, за исключением блока "reception" при помощи специального класса "_hide".
---
&nbsp;

---
### Основа готова, теперь модальные окна открываются при клике на кнопки авторизации и закрываются при нажатии на клавишу "Esc". Теперь разберем закрытие модальных окон при нажитии за пределами модальных окон и закрытие при нажатии на кнопку закрыть.
---
&nbsp;

---
### Закрытие окна при нажатии на кнопку легко реализуемо.

```

document.querySelectorAll('.modal-project-close').forEach(function (element) {
    element.onclick = closeModal;
});

```

### Кнопке с классом ".modal-project-close" вешается уже знакомая нам ранее функция закрытия модального окна "closeModal()".
---
&nbsp;

---
### А вот закрытие окна при нажатии за пределами этого окна - сложнее.
### Для начала получаем все модальные окна и вышаем им события клик с функцией "closeModal()". Теперь окно будут закрываться при клике за его пределами.

```

document.querySelectorAll('.modal-wrap').forEach(function (element) {
    element.onclick = closeModal;
});

```

### Но также оно будет закрываться и при клике на нем самом.
### Для того чтобы этого не было, указываем для блоков "#login-in .modal-project" и "#sign-up .modal-project" остановку выполнения события ("event.stopPropagation()").

```

document.querySelector('#login-in .modal-project').onclick = function (event) {
    event.stopPropagation();
}

document.querySelector('#sign-up .modal-project').onclick = function (event) {
    event.stopPropagation();
}

```

### Теперь на самом родителе ".modal-wrap" висит событие с закрытием окна, а для его наследников, блоков с формой, этого события нет - позволяя нам корректно закрывать модальное окно при клике за его пределами.
---
&nbsp;

---
### Осталось разобрать слайдер с правилами пользования. Разберем принцип его работы.
### Пункт "read rules" есть только при регистрации пользователя, он может прочитать их, согласится с правилами и зарегистрироваться, либо не соглашаться, тогда возможность регистрации будет для него недоступна.
### Сам слайдер состоит из двух блоков: блок с формой регистрации; блок с правилами пользования. Слайдер будет показывать блок с правилами при нажатии на "Read Rules" и скрывать его и возвращаться к блоку с формой.
### Оба блока обрезаются при помощи CSS - свойства: "overflow: hidden". Путем изменения свойства "margin-left", блоки будут двигать друг друга становясь видимыми пользователю.
---
&nbsp;

---
### Теперь разберем его скрипты.
### Для того чтобы показать правила - на span с классом "read-rules", вешается событие клик с анонимной функцией.

```

document.querySelector('.read-rules').onclick = function () {
    if (window.innerWidth <= 420) {
        document.querySelector('.form-slider').style.marginLeft = '-255px';
    }
    else if (window.innerWidth > 420) {
        document.querySelector('.form-slider').style.marginLeft = '-345px';
    }
}

```

### Затем применяются условия в зависимости от ширины окна браузера пользователя: если ширина браузера меньше или равна "420px" - то блоку "form-slider" присваивается "marginLeft" равный "-255px"; если же ширина браузера больше "420px" - то блоку "form-slider" присваивается "marginLeft" равный "-345px". 
### Эти условия нужны для корректного отображения слайдера на мобильной версии.
---
&nbsp;

---
### Для того чтобы вернутся к форме, на параграф с классом "read-rules-back" вешается событие клик с анонимной функцией.

```

document.querySelector('.read-rules-back').onclick = function () {
    document.querySelector('.form-slider').style.marginLeft = '0';
}

```

### Внутри функции блоку "form-slider" присваивается CSS-свойство "margin-left" со значением "0".
---
&nbsp;

---
### Если вы используя мобильное устройство, перешли на вкладку с условиями, и в процессе чтения условий, решили поменять ориентацию экрана перевернув свое устройство в вертикальное или горизонтальное положение, то заметили бы что весь блок с текстом начал отображаться неккоректно. Дело в том, что при динамическом изменении размера окна браузера, блок слайдера не регулирует свойство "marginLeft", оставшееся после применения события "onclick". В связи с этим, блок с условиями пользования выезжает не с тем значением, которое должно быть в событии "onclick", потому-что событие "onclick" работает один раз и только при нажатии. Чтобы исправить подобное, я написал небольшой код с определенными условиями. 
### Итак, на окно браузера мы вешаем слушатель событий со свойством "resize" - оно будет следить за изменением размера окна браузера. При каждом изменении размера окна, мы будем запускать функцию "sliderWork()".

```

window.addEventListener('resize', function() {
  sliderWork();
});

```

### В функции "sliderWork()", мы получаем сам блок "form-slider".
### Для того чтобы при динамическом изменении ширины окна браузера, корректно отображать слайдер с условиями, нужно получить текущий "marginLeft" и присвоить новый, в зависимости от размера окна браузера. Но изменять мы будем только тот "marginLeft", который не соответствует мобильной версии или десктопной.

```

function sliderWork (){
    let slider = document.querySelector('.form-slider');
    
    if (window.innerWidth <= 420) {
        if (slider.style.marginLeft == '-345px') {
            slider.style.marginLeft = '-255px';
        }
    }
    else if (window.innerWidth > 420) {
        if (slider.style.marginLeft == '-255px') {
            slider.style.marginLeft = '-345px';
        }
    }
}

```

### Итак, разберем условия: если ширина окна меньше или равна "420px" - то мы проверяем свойство "marginLeft", если оно равно "-345px" ("десктопная версия"), то мы изменяем "marginLeft" на "-255px" ("мобильная версия"); если ширина окна больше "420px" - то мы проверяем свойство "marginLeft", если оно равно "-255px" ("мобильная версия"), то мы изменяем "marginLeft" на "-345px" ("десктопная версия");  
### На этом работа слайдера закончена. Последнее что стоит разобрать - это согласие с правилами пользования.
---
&nbsp;

---
### На checkbox с классом "agree-rules" вешается событие "onchange" с анонимной функцией.

```

document.querySelector('#agree-rules').onchange = function () {
    if (this.checked) {
        document.querySelector('#signup-submit').classList.remove('disabled');
    }
    else {
        document.querySelector('#signup-submit').classList.add('disabled');
    }
}

```

### Внутри функции проходит простая проверка на "checked": если пункт выбран, то кнопке регистрации удаляется класс "disabled" - делая ее активной; если пункт не выбран, то кнопке регистрации присваевается класс "disabled" - делая ее неактивной.
### Класс "disabled" от "Materialize", позволяет отключить взаимодейстивие с кнопкой, достаточно просто его удалить чтобы кнопка вновь стала активной.  
---
&nbsp;

# 4. Заключение
&nbsp;

---
### Еще одно приложение с использованием баз данных "sql", которое структурно легко реализуемо, но имеющие много подводных камней. С чем же я столкнулся при разработке? Как обычно: ошибки в запросах, неккоректно прописанные имена переменных, изначально неправильно написанная серверная часть. Очень нелегко писать ajax-запросы туда, где у тебя хромает бэкенд. Что я могу сказать, бэкенд не сильная моя сторона, еще многому стоит научиться в этой среде, но всегда приятно видеть результат своих мучений! Понравилось работать с "cookie" файлами, теперь есть понимание администратирования сервера. Хороший опыт, полезные знания, рабочее приложение - время потрачено не зря!
---
&nbsp;

# ___Спасибо за уделенное время!___  